import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { useSelector } from "react-redux";
import { RootState, AppThunk } from "../../app/store";
//import { fetchCount } from "./counterAPI";

export interface TaskState {
	idCount: number; //タスク数を管理
	tasks: { id: number; title: string; completed: boolean }[]; //storeに保存するタスク一覧
	selectedTask: { id: number; title: string; completed: boolean }; //タスクのタイトル編集時にどれかを示す
	isModalOpen: boolean; //モーダルの開閉フラグ
}

const initialState: TaskState = {
	idCount: 1,
	tasks: [{ id: 1, title: "Task A", completed: false }],
	selectedTask: { id: 0, title: "", completed: false },
	isModalOpen: false,
};

export const taskSlice = createSlice(
	{
		name: "task",
		initialState,
		// The `reducers` field lets us define reducers and generate associated actions
		reducers: {
			//タスクの作成
			createTask: (state, action) => {
				state.idCount++;
				const newTask = {
					id: state.idCount,
					title: action.payload,
					completed: false,
				};
				state.tasks = [newTask, ...state.tasks];
			},
			//タスクの編集
			editTask: (state, action) => {
				// state.tasksの中から指定したタスクを抜き出す
				const task = state.tasks.find((t) => t.id === action.payload.id);
				if (task) {
					task.title = action.payload.title;
				}
			},
			// タスクの削除
			deleteTask: (state, action) => {
				//指定したタスク以外で新しくstate.tasksの配列を作成しなおしている
				state.tasks = state.tasks.filter((t) => t.id !== action.payload.id);
			},
			//どのタスクを選択しているか管理
			selectTask: (state, action) => {
				state.selectedTask = action.payload;
			},
			//Modalの開閉のフラグ管理
			handleModalOpen: (state, action) => {
				state.isModalOpen = action.payload;
			},
			// タスク完了・未完了のチェックを変更
			completeTask: (state, action) => {
				// state.tasksの中から指定したタスクを抜き出す
				const task = state.tasks.find((t) => t.id === action.payload.id);
				if (task) {
					//抜き出したタスクのcompletedを反転
					task.completed = !task.completed;
				}
			},
		},
	}
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	// extraReducers: (builder) => {
	// 	builder
	// 		.addCase(incrementAsync.pending, (state) => {
	// 			state.status = "loading";
	// 		})
	// 		.addCase(incrementAsync.fulfilled, (state, action) => {
	// 			state.status = "idle";
	// 			state.value += action.payload;
	// 		});
	// },
);

export const {
	createTask,
	editTask,
	deleteTask,
	selectTask,
	handleModalOpen,
	completeTask,
} = taskSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectTasks = (state: RootState): TaskState["tasks"] =>
	state.task.tasks;

export const selectIsModalOpen = (state: RootState): TaskState["isModalOpen"] =>
	state.task.isModalOpen;

export const selectSelectedTask = (
	state: RootState
): TaskState["selectedTask"] => state.task.selectedTask;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
// 	(amount: number): AppThunk =>
// 	(dispatch, getState) => {
// 		const currentValue = selectCount(getState());
// 		if (currentValue % 2 === 1) {
// 			dispatch(incrementByAmount(amount));
// 		}
// 	};

export default taskSlice.reducer;
