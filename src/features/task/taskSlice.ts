import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import firebase from "firebase/compat/app";
import { useSelector } from "react-redux";
import { RootState, AppThunk } from "../../app/store";
import { db } from "../../firebase";
//import { fetchCount } from "./counterAPI";

export interface TaskState {
	idCount: number; //タスク数を管理
	tasks: { id: string; title: string; completed: boolean }[]; //storeに保存するタスク一覧
	selectedTask: { id: string; title: string; completed: boolean }; //タスクのタイトル編集時にどれかを示す
	isModalOpen: boolean; //モーダルの開閉フラグ
}

const initialState: TaskState = {
	idCount: 1,
	tasks: [],
	selectedTask: { id: "", title: "", completed: false },
	isModalOpen: false,
};

/* =============================
	Taskの全件取得
============================= */

export const fetchTasks = createAsyncThunk("task/getAllTasks", async () => {
	const res = await db.collection("tasks").orderBy("dateTime", "desc").get();

	const allTasks = res.docs.map((doc) => ({
		id: doc.id,
		title: doc.data().title,
		completed: doc.data().completed,
	}));

	const taskNumber = allTasks.length;
	const passData = { allTasks, taskNumber };
	return passData;
});

/* =============================
	Taskの新規作成
============================= */

export const createTask = async (title: string): Promise<void> => {
	try {
		//現在時刻の取得
		const dateTime = firebase.firestore.Timestamp.fromDate(new Date());
		//fireStoreのtaskコレクションにデータを追加(idは自動で割り当て)
		await db
			.collection("tasks")
			.add({ title: title, completed: false, dateTime: dateTime });
	} catch (err) {
		console.log("Error writing document: ", err);
	}
};

/* =============================
	Taskの編集
============================= */

export const editTask = async (submitData: {
	id: string;
	title: string;
	completed: boolean;
}): Promise<void> => {
	const { id, title, completed } = submitData;
	const dateTime = firebase.firestore.Timestamp.fromDate(new Date());
	try {
		await db
			.collection("tasks")
			.doc(id)
			.set({ title, completed, dateTime }, { merge: true });
	} catch (err) {
		console.log("Error updating document: ", err);
	}
};

/* =============================
	Taskの削除
============================= */

export const deleteTask = async (id: string): Promise<void> => {
	try {
		await db.collection("tasks").doc(id).delete();
	} catch (err) {
		console.log("error removing document: ", err);
	}
};

export const taskSlice = createSlice(
	{
		name: "task",
		initialState,
		// The `reducers` field lets us define reducers and generate associated actions
		reducers: {
			//どのタスクを選択しているか管理
			selectTask: (state, action) => {
				state.selectedTask = action.payload;
			},
			//Modalの開閉のフラグ管理
			handleModalOpen: (state, action) => {
				state.isModalOpen = action.payload;
			},
		},
		extraReducers: (builder) => {
			//stateとactionの型が正しく推論されるためにbuilder関数を用いる
			builder.addCase(fetchTasks.fulfilled, (state, action) => {
				//action.payload === return passData;
				state.tasks = action.payload.allTasks;
				state.idCount = action.payload.taskNumber;
			});
		},
	}
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	// extraReducers: (builder) => {
	// 	builder
	// 		.addCase(incrementAsync.pending, (state) => {
	// 			state.status = "loading";
	// 		})
	// 		.addCase(incrementAsync.fulfilled, (state, action) => {
	// 			state.status = "idle";
	// 			state.value += action.payload;
	// 		});
	// },
);

export const { selectTask, handleModalOpen } = taskSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectTasks = (state: RootState): TaskState["tasks"] =>
	state.task.tasks;

export const selectIsModalOpen = (state: RootState): TaskState["isModalOpen"] =>
	state.task.isModalOpen;

export const selectSelectedTask = (
	state: RootState
): TaskState["selectedTask"] => state.task.selectedTask;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
// 	(amount: number): AppThunk =>
// 	(dispatch, getState) => {
// 		const currentValue = selectCount(getState());
// 		if (currentValue % 2 === 1) {
// 			dispatch(incrementByAmount(amount));
// 		}
// 	};

export default taskSlice.reducer;
